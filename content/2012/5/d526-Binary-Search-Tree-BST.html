title=〔高中生程式解題系統〕d526: Binary Search Tree (BST)
date=2012-05-18 23:09
full_date=2012-05-18T23:09:00.000+08:00
type=post
allowComment=true
tags=【競賽＆解題】, 〔高中生程式解題系統〕
status=published
~~~~~~

題目：<a href="http://zerojudge.tw/ShowProblem?problemid=d526">http://zerojudge.tw/ShowProblem?problemid=d526</a><br /><!--more-->Java： <br /><pre class="brush:java">/**********************************************************************************/<br />/*  Problem: d526 "Binary Search Tree (BST)" from BST                             */<br />/*  Language: JAVA (6086 Bytes)                                                   */<br />/*  Result: AC(1.3s, 28.4MB) judge by this@ZeroJudge                              */<br />/*  Author: mushiyo at 2012-05-18 22:53:27                                        */<br />/**********************************************************************************/<br /><br /><br />import java.util.Scanner;<br />import java.util.Iterator;<br />import java.util.ArrayList;<br /><br />public class d526 {<br /><br /> public static void main(String[] args) {<br />  Scanner input = new Scanner(System.in);<br />  <br />  while(input.hasNext()){<br />   int N = input.nextInt();<br />   Integer[] M = new Integer[N];<br />   <br />   for(int i = 0; i &lt; M.length; ++i){<br />    M[i] = input.nextInt();<br />   }<br />   <br />   BinaryTree tree = new BinaryTree&lt;Integer&gt;(M);<br />   Iterator iterate = tree.preorderIterator();<br />   while(iterate.hasNext()){<br />    if(N &gt; 1){<br />        System.out.print(iterate.next() + " ");<br />    }<br />    else{<br />     System.out.print(iterate.next());<br />    }<br />    <br />    --N;<br />   }<br /><br />   System.out.println();<br />  }<br /> }<br />}<br /><br />interface Tree&lt;E extends Comparable&lt;E&gt;&gt; {<br />    //Return true if element found.<br /> public boolean search(E e);<br />    <br /> //Insert element e into the tree<br /> //return true if insert successfully<br />    public boolean insert(E e);<br />    <br />    //return # of nodes in the tree<br />    public int getSize();<br />    <br />    //return true if the tree is empty<br />    public boolean isEmpty();<br />    <br />    //return an iterator to traverse elements in the tree<br />    public Iterator iterator();<br />}<br /><br />abstract class AbstractTree&lt;E extends Comparable&lt;E&gt;&gt; implements Tree&lt;E&gt; {<br />  //return true if the tree is empty<br />    public boolean isEmpty(){<br />     return getSize() == 0;<br />    }<br />    <br />    //return an iterator to traverse elements in the tree<br />    public Iterator iterator(){<br />     return null;<br />    }<br />}<br /><br />class BinaryTree&lt;E extends Comparable&lt;E&gt;&gt; extends AbstractTree&lt;E&gt; {<br />    protected TreeNode&lt;E&gt; root;<br />    protected int size = 0;<br />    <br />    public BinaryTree(){<br />    }<br />    <br />    public BinaryTree(E[] objects){<br />     for(int i = 0; i &lt; objects.length; ++i){<br />      insert(objects[i]);<br />     }<br />    }<br />    <br />    public boolean search(E e){<br />     TreeNode&lt;E&gt; current = root;<br />     <br />     while(current != null){<br />      if(e.compareTo(current.element) &lt; 0){<br />       current = current.left;<br />      }<br />      else if(e.compareTo(current.element) &gt; 0){<br />       current = current.right;<br />      }<br />      else{<br />       return true;<br />      }<br />     }<br />     <br />     return false;<br />    }<br /><br />    public boolean insert(E e){<br />     if(root == null){<br />      root = createNewNode(e);<br />     }<br />     else{<br />      TreeNode&lt;E&gt; parent = null;<br />      TreeNode&lt;E&gt; current = root;<br />      <br />      while(current != null){<br />       if(e.compareTo(current.element) &lt; 0){<br />        parent = current;<br />        current = current.left;<br />       }<br />       else if(e.compareTo(current.element) &gt; 0){<br />        parent = current;<br />        current = current.right;<br />       }<br />       else{<br />        return false;<br />       }<br />      }<br />      <br />      if(e.compareTo(parent.element) &lt; 0){<br />       parent.left = createNewNode(e);<br />      }<br />      else{<br />       parent.right = createNewNode(e);<br />      }<br />     }<br />     <br />     ++size;<br />  <br />  return true;<br />    }<br />    <br />    protected TreeNode&lt;E&gt; createNewNode(E e){<br />     return new TreeNode&lt;E&gt;(e);<br />    }<br />    <br />    public static class TreeNode&lt;E extends Comparable&lt;E&gt;&gt;{<br />     E element;<br />     TreeNode&lt;E&gt; left;<br />     TreeNode&lt;E&gt; right;<br />     <br />     public TreeNode(E e){<br />      element = e;<br />     }<br />    }<br />    <br />    public int getSize(){<br />     return size;<br />    }<br />    <br />    public TreeNode getRoot(){<br />     return root;<br />    }<br />    <br />    public ArrayList&lt;TreeNode&lt;E&gt;&gt; path(E e){<br />     ArrayList&lt;TreeNode&lt;E&gt;&gt; list = new ArrayList&lt;TreeNode&lt;E&gt;&gt;();<br />     TreeNode&lt;E&gt; current = root;<br />     <br />     while(current != null){<br />      list.add(current);<br />      <br />      if(e.compareTo(current.element) &lt; 0){<br />       current = current.left;<br />      }<br />      else if(e.compareTo(current.element) &gt; 0){<br />       current = current.right;<br />      }<br />      else{<br />       break;<br />      }<br />     }<br />     <br />     return list;<br />    }<br /><br />    public boolean delete(E e){<br />     TreeNode&lt;E&gt; parent = null;<br />     TreeNode&lt;E&gt; current = root;<br />     <br />     while(current != null){<br />      if(e.compareTo(current.element) &lt; 0){<br />       parent = current;<br />       current = current.left;<br />      }<br />      else if(e.compareTo(current.element) &gt; 0){<br />       parent = current;<br />       current = current.right;<br />      }<br />      else{<br />       break;<br />      }<br />     }<br />     <br />     if(current == null){<br />      return false;<br />     }<br />     <br />     if(current.left == null){<br />      if(parent == null){<br />       root = current.right;<br />      }<br />      else{<br />       if(e.compareTo(parent.element) &lt; 0){<br />        parent.left = current.right;<br />       }<br />       else{<br />        parent.right = current.right;<br />       }<br />      }<br />     }<br />     else{<br />      TreeNode&lt;E&gt; parentOfRightMost = current;<br />      TreeNode&lt;E&gt; rightMost = current.left;<br />      <br />      while(rightMost.right != null){<br />       parentOfRightMost = rightMost;<br />       rightMost = rightMost.right;<br />      }<br />      <br />      current.element = rightMost.element;<br />      <br />      if(parentOfRightMost.right == rightMost){<br />       parentOfRightMost.right = rightMost.left;<br />      }<br />      else{<br />       parentOfRightMost.left = rightMost.left;<br />      }<br />     }<br />     <br />     --size;<br />     <br />     return true;<br />    }<br />    <br />    public Iterator iterator(){<br />     return preorderIterator();<br />    }<br />    <br />    public Iterator preorderIterator(){<br />     return new PreorderIterator();<br />    }<br />    <br />    class PreorderIterator implements Iterator{<br />     private ArrayList&lt;E&gt; list = new ArrayList&lt;E&gt;();<br />     private int current = 0;<br />     <br />     public PreorderIterator(){<br />      preorder();<br />     }<br />     <br />     private void preorder(){<br />      preorder(root);<br />     }<br />     <br />     private void preorder(TreeNode&lt;E&gt; root){<br />      if(root == null){<br />       return;<br />      }<br />      <br />      list.add(root.element);<br />      preorder(root.left);<br />      preorder(root.right);<br />     }<br />     <br />     public boolean hasNext(){<br />      if(current &lt; list.size()){<br />       return true;<br />      }<br />      <br />      return false;<br />     }<br />     <br />     public Object next(){<br />      return list.get(current++);<br />     }<br />     <br />     public void remove(){<br />      delete(list.get(current));<br />      list.clear();<br />      preorder();<br />     }<br />    }<br />}<br /><br /></pre>
