title=〔UVa〕1589 - Xiangqi
date=2015-02-08 23:04
full_date=2015-02-08T23:04:00.001+08:00
type=post
allowComment=true
tags=〔UVa〕, 【競賽＆解題】
status=published
~~~~~~

Problem：<a href="http://uva.onlinejudge.org/external/15/1589.html">http://uva.onlinejudge.org/external/15/1589.html</a><br /><!--more--><br />Solution Description:<br />Try all the possible next moves of the black general. If there's one move which makes the black general is not being checked, then output "NO"; if&nbsp; the black general is still checked no matter where it moves, output "YES". Note the possible next moves of the black general may include capture moves, i.e.  the black general  may capture a red piece when it moves. This situation must be handled to get AC.<br /><br />Java：<br /><pre class="brush:java">/* Filename: UVa1589.java<br /> * Author: Mushiyo<br /> */<br /><br />import java.util.Scanner;<br />import java.util.Arrays;<br />import java.util.ArrayList;<br /><br />public class UVa1589 {<br /> private static final char[][] board = new char[10 + 1][9 + 1];<br /> private static final int G_INDEX = 0;<br /> private static final char EMPTY = '.';<br /><br /> private static final int[] G_DIRECTX = { -1, 1, 0, 0 };<br /> private static final int[] G_DIRECTY = { 0, 0, -1, 1 };<br /> private static final int[] H_DIRECTX = { -2, -1, 1, 2, 2, 1, -1, -2 };<br /> private static final int[] H_DIRECTY = { 1, 2, 2, 1, -1, -2, -2, -1 };<br /> private static final int[] HOBBLEX = { -1, 0, 0, 1, 1, 0, 0, -1 };<br /> private static final int[] HOBBLEY = { 0, 1, 1, 0, 0, -1, -1, 0 };<br /><br /> public static void main(String[] args) {<br />  Scanner input = new Scanner(System.in);<br /><br />  while (input.hasNext()) {<br />   int N = input.nextInt();<br /><br />   if (N == 0) {<br />    break;<br />   }<br /><br />   Piece[] pieces = new Piece[N + 1];<br />   pieces[G_INDEX] = new Piece('g', new Point(input.nextInt(),<br />     input.nextInt()));<br /><br />   for (int i = 1; i &lt; pieces.length; ++i) {<br />    pieces[i] = new Piece(input.next().charAt(0), new Point(<br />      input.nextInt(), input.nextInt()));<br />   }<br /><br />   setBoard(pieces);<br /><br />   if (isCheckmate(pieces)) {<br />    System.out.println("YES");<br />   } else {<br />    System.out.println("NO");<br />   }<br />  }<br /> }<br /><br /> private static void setBoard(Piece[] pieces) {<br />  for (int i = 0; i &lt; board.length; ++i) {<br />   Arrays.fill(board[i], EMPTY);<br />  }<br /><br />  for (int i = 1; i &lt; pieces.length; ++i) {<br />   board[pieces[i].position.x][pieces[i].position.y] = pieces[i].type;<br />  }<br /> }<br /><br /> private static void printBoard() {<br />  for (int i = 1; i &lt; board.length; ++i) {<br />   System.out.println(board[i]);<br />  }<br /><br />  System.out.println("-----");<br /> }<br /><br /> private static boolean isCheckmate(Piece[] pieces) {<br />  Point[] gMove = genMove(pieces[G_INDEX]);<br /><br />  for (int g = 0; g &lt; gMove.length; ++g) {<br />   char original = board[gMove[g].x][gMove[g].y];<br />   board[gMove[g].x][gMove[g].y] = 'g';<br />   pieces[G_INDEX].position = gMove[g];<br /><br />   boolean isChecked = false;<br />   for (int i = 1; i &lt; pieces.length &amp;&amp; isChecked == false; ++i) {<br />    if (pieces[i].position.equals(gMove[g])) {<br />     continue;<br />    }<br /><br />    switch (pieces[i].type) {<br />    case 'G':<br />    case 'R':<br />     if (pieces[i].position.y == pieces[G_INDEX].position.y) {<br />      if (countPieceBetween(pieces[i], pieces[G_INDEX]) == 0) {<br />       isChecked = true;<br />      }<br />     }<br />     if (pieces[i].type == 'R'<br />       &amp;&amp; pieces[i].position.x == pieces[G_INDEX].position.x) {<br />      if (countPieceBetween(pieces[i], pieces[G_INDEX]) == 0) {<br />       isChecked = true;<br />      }<br />     }<br />     break;<br />    case 'H':<br />     Point[] move = genMove(pieces[i]);<br />     for (int m = 0; m &lt; move.length; ++m) {<br />      if (board[move[m].x][move[m].y] == 'g') {<br />       isChecked = true;<br />       break;<br />      }<br />     }<br />     break;<br />    case 'C':<br />     if ((pieces[i].position.y == pieces[G_INDEX].position.y)<br />       || pieces[i].position.x == pieces[G_INDEX].position.x) {<br />      if (countPieceBetween(pieces[i], pieces[G_INDEX]) == 1) {<br />       isChecked = true;<br />      }<br />     }<br />     break;<br />    }<br />   }<br /><br />   if (isChecked == false) {<br />    return false;<br />   }<br /><br />   board[gMove[g].x][gMove[g].y] = original;<br />  }<br /><br />  return true;<br /> }<br /><br /> private static Point[] genMove(Piece p) {<br />  ArrayList&lt;Point&gt; moveList = new ArrayList&lt;Point&gt;();<br />  if (p.type == 'g') {<br />   for (int i = 0; i &lt; G_DIRECTX.length; ++i) {<br />    int newGX = p.position.x + G_DIRECTX[i];<br />    int newGY = p.position.y + G_DIRECTY[i];<br />    if (1 &lt;= newGX &amp;&amp; newGX &lt;= 3) {<br />     if (4 &lt;= newGY &amp;&amp; newGY &lt;= 6) {<br />      moveList.add(new Point(newGX, newGY));<br />     }<br />    }<br />   }<br />  } else if (p.type == 'H') {<br />   for (int i = 0; i &lt; H_DIRECTX.length; ++i) {<br />    int newGX = p.position.x + H_DIRECTX[i];<br />    int newGY = p.position.y + H_DIRECTY[i];<br />    if (1 &lt;= newGX &amp;&amp; newGX &lt;= 10) {<br />     if (1 &lt;= newGY &amp;&amp; newGY &lt;= 9) {<br />      int hobbleX = p.position.x + HOBBLEX[i];<br />      int hobbleY = p.position.y + HOBBLEY[i];<br />      if (board[hobbleX][hobbleY] == EMPTY) {<br />       moveList.add(new Point(newGX, newGY));<br />      }<br />     }<br />    }<br />   }<br />  }<br /><br />  return moveList.toArray(new Point[moveList.size()]);<br /> }<br /><br /> // count how many pieces between piece p1 and p2<br /> private static int countPieceBetween(Piece p1, Piece p2) {<br />  int count = 0;<br /><br />  if (p1.position.y == p2.position.y) {<br />   int start = Math.min(p1.position.x, p2.position.x);<br />   int end = Math.max(p1.position.x, p2.position.x);<br /><br />   for (int i = start + 1; i &lt; end; ++i) {<br />    if (board[i][p1.position.y] != EMPTY) {<br />     ++count;<br />    }<br />   }<br />  } else { // p1.position.x == p2.position.x<br />   int start = Math.min(p1.position.y, p2.position.y);<br />   int end = Math.max(p1.position.y, p2.position.y);<br /><br />   for (int i = start + 1; i &lt; end; ++i) {<br />    if (board[p1.position.x][i] != EMPTY) {<br />     ++count;<br />    }<br />   }<br />  }<br /><br />  return count;<br /> }<br /><br /> private static class Piece {<br />  char type;<br />  Point position;<br /><br />  Piece(char type, Point p) {<br />   this.type = type;<br />   position = p;<br />  }<br /> }<br /><br /> private static class Point {<br />  int x, y;<br /><br />  Point(int x, int y) {<br />   this.x = x;<br />   this.y = y;<br />  }<br /><br />  public boolean equals(Object p) {<br />   return this.x == ((Point) p).x &amp;&amp; this.y == ((Point) p).y;<br />  }<br /><br />  public String toString() {<br />   return String.format("(%d, %d)", x, y);<br />  }<br /> }<br />}<br /><br /></pre>
