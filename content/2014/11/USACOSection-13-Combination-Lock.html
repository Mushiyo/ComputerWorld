title=〔USACO〕Section 1.3 Combination Lock
date=2014-11-17 22:15
full_date=2014-11-17T22:15:00.000+08:00
type=post
allowComment=true
tags=〔USACO〕, 【競賽＆解題】
status=published
~~~~~~

Problem：<a href="http://cerberus.delosent.com:791/usacoprob2?a=FyeWdZ8mbF6&amp;S=combo">http://cerberus.delosent.com:791/usacoprob2?a=FyeWdZ8mbF6&amp;S=combo</a><br /><!--more--><br />Solution Description:<br />Since the lock has three dials and each dial ranged from 1~100, there are only \(100^3 = 1,000,000\) possible locks, which is not a large number. Hence, just enumerate all the possible lock and count how many of them falls within at most 2 positions of the two valid combination, i.e. Farmer John's combination and the master combination. Note 1 and N are considered to be adjacent in the problem, so if the distance between two number ≧ N - 2, they are consider too.<br />If you can't understand my solution and wish a more detailed one, you can read the official solution: <a href="http://usaco.org/current/data/sol_combo.html">http://usaco.org/current/data/sol_combo.html</a><br /><br />Java：<br /><pre class="brush:java">/*<br />ID: mushiyo1<br />LANG: JAVA<br />TASK: combo<br /> */<br /><br />import java.io.File;<br />import java.io.FileNotFoundException;<br />import java.io.PrintWriter;<br />import java.util.Scanner;<br /><br />public class combo {<br /><br /> public static void main(String[] args) throws FileNotFoundException {<br />  Scanner input = new Scanner(new File("combo.in"));<br />  PrintWriter output = new PrintWriter("combo.out");<br />  final int SIZE = 3;<br /><br />  while (input.hasNext()) {<br />   int N = input.nextInt();<br />   int[] John = new int[SIZE];<br />   int[] master = new int[SIZE];<br /><br />   for (int i = 0; i &lt; John.length; ++i) {<br />    John[i] = input.nextInt();<br />   }<br /><br />   for (int i = 0; i &lt; master.length; ++i) {<br />    master[i] = input.nextInt();<br />   }<br /><br />   output.println(countDistinct(N, John, master));<br />  }<br /><br />  input.close();<br />  output.close();<br /> }<br /><br /> public static int countDistinct(int N, int[] lock1, int[] lock2) {<br />  int distinctSetting = 0;<br /><br />  for (int i = 1; i &lt;= N; ++i) {<br />   for (int j = 1; j &lt;= N; ++j) {<br />    for (int k = 1; k &lt;= N; ++k) {<br />     if (canOpen(N, i, j, k, lock1)<br />       || canOpen(N, i, j, k, lock2)) {<br />      ++distinctSetting;<br />     }<br />    }<br />   }<br />  }<br /><br />  return distinctSetting;<br /> }<br /><br /> public static boolean canOpen(int N, int a, int b, int c, int[] lock) {<br />  if ((Math.abs(a - lock[0]) &lt;= 2 || Math.abs(a - lock[0]) &gt;= N - 2)<br />    &amp;&amp; (Math.abs(b - lock[1]) &lt;= 2 || Math.abs(b - lock[1]) &gt;= N - 2)<br />    &amp;&amp; (Math.abs(c - lock[2]) &lt;= 2 || Math.abs(c - lock[2]) &gt;= N - 2)) {<br />   return true;<br />  }<br /><br />  return false;<br /> }<br />}  </pre><br />Things unrelated to the problem:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://www.mediafire.com/convkey/9b38/moha73h4z5o26cu6g.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="640" src="https://www.mediafire.com/convkey/9b38/moha73h4z5o26cu6g.jpg" width="408" /></a></div><br />I haven't logged in USACO for a long time since I got stuck in section 1.4 in 2012. Recently I came up with a solution to one of the problem and want to test if my solution is correct. However, when I logged in the system (which has a new URL different from that in my 2012 memory), I found they changed the problem set, so I was (a little bit sadly) "repelled" back to section 1.3.<br /><br />But after read the newly added problems and the new problem set of section 1.4, I found that maybe (just maybe) I can reach section 1.5 this time! Well, let's wait and see.
