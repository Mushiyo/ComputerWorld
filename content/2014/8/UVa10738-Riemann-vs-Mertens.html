title=〔UVa〕10738 - Riemann vs Mertens
date=2014-08-20 17:59
full_date=2014-08-20T17:59:00.001+08:00
type=post
allowComment=true
tags=〔UVa〕, 【競賽＆解題】
status=published
~~~~~~

Problem：<a href="http://uva.onlinejudge.org/external/107/10738.html">http://uva.onlinejudge.org/external/107/10738.html</a><br /><!--more--><br />Solution Description:<br />To save time when doing query, compute all mu(N) and M(N) in advance.<br />To compute mu(N) efficiently, use sieve method to distinguish prime and composite.<br />After that, factorize every composite to determine its mu() value, then calculate M() for all numbers.<br /><br />Java：<br /><pre class="brush:java">/* Filename: UVa10738.java<br /> * Author: Mushiyo<br /> */<br /><br />import java.util.Arrays;<br />import java.util.Scanner;<br /><br />public class UVa10738 {<br /> static final int SIZE = 1000000 + 1;<br /> static int[] mu = new int[SIZE];<br /> static int[] M = new int[SIZE];<br /> final static int prime = -1;<br /> final static int composite = 2;<br /> final static int notSquareFree = 0;<br /> final static int squareFreeAndEven = 1;<br /> final static int squareFreeAndOdd = -1;<br /><br /> static void computeMuAndM() {<br />  Arrays.fill(mu, -1);<br />  mu[1] = 1;<br />  M[1] = 1;<br /><br />  int sqrtSize = (int) Math.sqrt(SIZE) + 1;<br /><br />  // sieve all the prime<br />  for (int i = 2; i &lt; sqrtSize; ++i) {<br />   if (mu[i] == prime) {<br />    for (int j = i * i; j &lt; SIZE; j += i) {<br />     mu[j] = composite;<br />    }<br />   }<br />  }<br /><br />  for (int n = 2; n &lt; SIZE; ++n) {<br />   if (mu[n] == composite &amp;&amp; mu[n] != notSquareFree) {<br />    int currentN = n;<br />    int sqrtN = (int) Math.sqrt(n);<br />    int factorNum = 0;<br /><br />    for (int i = 2; i &lt;= sqrtN; ++i) {<br />     if (currentN % i == 0) {<br />      ++factorNum;<br />     }<br /><br />     int countFactor = 0;<br />     while (currentN % i == 0 &amp;&amp; countFactor &lt; 2) {<br />      ++countFactor;<br />      currentN /= i;<br />     }<br /><br />     // if n is not square free, all the multiples of n is not<br />     // square free<br />     if (countFactor &gt;= 2) {<br />      for (int multipleN = n; multipleN &lt; SIZE; multipleN += n) {<br />       mu[multipleN] = notSquareFree;<br />      }<br /><br />      break;<br />     }<br />    }<br />    <br />    if(currentN != 1){<br />     ++factorNum;<br />    }<br /><br />    if (mu[n] != notSquareFree) {<br />     if (factorNum % 2 == 1) {<br />      mu[n] = squareFreeAndOdd;<br />     } else {<br />      mu[n] = squareFreeAndEven;<br />     }<br />    }<br />   }<br />  }<br /><br />  // compute M[n]<br />  for (int i = 2; i &lt; M.length; ++i) {<br />   M[i] = M[i - 1] + mu[i];<br />  }<br /> }<br /><br /> public static void main(String[] args) {<br />  computeMuAndM();<br />  Scanner input = new Scanner(System.in);<br /><br />  while (input.hasNext()) {<br />   int n = input.nextInt();<br />   <br />   if(n == 0){<br />    break;<br />   }<br />   <br />   System.out.printf("%8d%8d%8d\n", n, mu[n], M[n]);<br />  }<br /> }<br /><br />}<br /><br /></pre>
