title=〔UVa〕11520 - Fill the Square
date=2013-12-24 20:45
full_date=2013-12-24T20:45:00.000+08:00
type=post
allowComment=true
tags=〔UVa〕, 【競賽＆解題】
status=published
~~~~~~

題目：<a href="http://uva.onlinejudge.org/external/115/11520.html">http://uva.onlinejudge.org/external/115/11520.html</a><br /><!--more--><br />解題雜記：<br />　　由上至下由左至右的掃過格子，並填入目前所能填入格子的字母中，最小的那個字母即可。<br /><br />Solution Description:<br />&nbsp;&nbsp;&nbsp; From top to down, left to right, scan through the gird cell by cell, fill the current cell with the smallest alphabet among all the alphabets which can be filled in.<br /><br />Java：<br /><pre class="brush:java">/* Filename: UVa11520.java<br /> * Author: Mushiyo<br /> */<br /><br />import java.util.Scanner;<br />import java.util.Arrays;<br /><br />public class UVa11520 {<br /> final static int DIRECTION = 4;<br /> final static int[] dx = { 0, -1, 1, 0 };<br /> final static int[] dy = { -1, 0, 0, 1 };<br /> // the 4 direction left, up, down, right<br /><br /> public static char fillChar(char[][] grid, int x, int y){<br />  for(int i = 0; i &lt; 26; ++i){<br />   boolean canFill = true;<br />    for(int d = 0; d &lt; DIRECTION; ++d){<br />     if('A' + i == grid[x + dx[d]][y + dy[d]]){<br />      canFill = false;<br />      break;<br />     }<br />    }<br />    <br />    if(canFill){<br />     return (char)('A' + i);<br />    }<br />  }<br />  <br />  return 'A';<br /> }<br /><br /> public static void main(String[] args) {<br />  final char SPACE = '.';<br />  final int maxN = 10 + 2;<br />  char[][] grid = new char[maxN][maxN];<br />  Scanner input = new Scanner(System.in);<br /><br />  while (input.hasNext()) {<br />   int testCase = input.nextInt();<br /><br />   for (int c = 1; c &lt;= testCase; ++c) {<br />    int n = input.nextInt();<br /><br />    for (int i = 0; i &lt; grid.length; ++i) {<br />     Arrays.fill(grid[i], SPACE);<br />    }<br /><br />    for (int i = 1; i &lt;= n; ++i) {<br />     String row = input.next();<br /><br />     for (int j = 1; j &lt;= n; ++j) {<br />      grid[i][j] = row.charAt(j - 1);<br />     }<br />    }<br /><br />    for (int i = 1; i &lt;= n; ++i) {<br />     for (int j = 1; j &lt;= n; ++j) {<br />      if (grid[i][j] == SPACE) {<br />       grid[i][j] = fillChar(grid, i, j);<br />      }<br />     }<br />    }<br /><br />    System.out.printf("Case %d:\n", c);<br />    for (int i = 1; i &lt;= n; ++i) {<br />     for (int j = 1; j &lt;= n; ++j) {<br />      System.out.print(grid[i][j]);<br />     }<br />     System.out.println();<br />    }<br />   }<br />  }<br /> }<br />}<br /><br /></pre><br />C++：<br /><pre class="brush:c">/*Filename: uva11520.cpp<br /> *Author: Mushiyo<br /> */<br /><br />#include &lt;iostream&gt;<br />#include &lt;cstdio&gt;<br />#include &lt;cstring&gt;<br /><br />using namespace std;<br /><br />const int DIRECTION = 4;<br />const int dx[] = { 0, -1, 1, 0 };<br />const int dy[] = { -1, 0, 0, 1 };<br />// the 4 direction left, up, down, right<br /><br />const char SPACE = '.';<br />const int maxN = 10 + 2;<br />char grid[maxN][maxN];<br /><br />char fillChar(int x, int y) {<br /> for (int i = 0; i &lt; 26; ++i) {<br />  bool canFill = true;<br />  for (int d = 0; d &lt; DIRECTION; ++d) {<br />   if ('A' + i == grid[x + dx[d]][y + dy[d]]) {<br />    canFill = false;<br />    break;<br />   }<br />  }<br /><br />  if (canFill) {<br />   return (char) ('A' + i);<br />  }<br /> }<br />}<br /><br />int main() {<br /> int testCase = 0;<br /><br /> while (cin &gt;&gt; testCase) {<br />  for (int c = 1; c &lt;= testCase; ++c) {<br />   int n = 0;<br />   cin &gt;&gt; n;<br /><br />   memset(grid, SPACE, sizeof(grid));<br /><br />   for (int i = 1; i &lt;= n; ++i) {<br />    for (int j = 1; j &lt;= n; ++j) {<br />     cin &gt;&gt; grid[i][j];<br />    }<br />   }<br /><br />   for (int i = 1; i &lt;= n; ++i) {<br />    for (int j = 1; j &lt;= n; ++j) {<br />     if (grid[i][j] == SPACE) {<br />      grid[i][j] = fillChar(i, j);<br />     }<br />    }<br />   }<br /><br />   printf("Case %d:\n", c);<br />   for (int i = 1; i &lt;= n; ++i) {<br />    for (int j = 1; j &lt;= n; ++j) {<br />     printf("%c", grid[i][j]);<br />    }<br />    printf("\n");<br />   }<br />  }<br /> }<br /><br /> return 0;<br />}<br /><br /></pre>
