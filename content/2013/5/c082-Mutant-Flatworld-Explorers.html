title=〔高中生程式解題系統〕c082: Mutant Flatworld Explorers
date=2013-05-21 22:47
full_date=2013-05-21T22:47:00.000+08:00
type=post
allowComment=true
tags=【競賽＆解題】, 〔高中生程式解題系統〕
status=published
~~~~~~

題目：<a href="http://zerojudge.tw/ShowProblem?problemid=c048">http://zerojudge.tw/ShowProblem?problemid=c048</a><br /><!--more--><br />解題雜記：<br />　　這題是模擬題。 注意題目敘述中的「掉下去的機器人會把標記，留在他掉落之前所在的最後一個坐標點」，因此標記不是留在機器人掉下去（出界）時的座標點，而都是在矩形土地上面。例如：在(0, 0) S的機器人接到F指令出界後，它會在(0, 0)留下記號。之後，如果有一個在(0, 0)W的機器人接到F指令，它會因為(0, 0)已經有記號了而忽略指令不會出界。（此例來自zerojudge的<a href="http://zerojudge.tw/ShowThread?postid=7487&amp;reply=0" target="_blank">討論板</a>，感謝<a href="http://zerojudge.tw/UserStatistic?account=passerr" target="_blank">passerr</a>大方分享心得）小心這點就可以順利AC了。<br /><br />Java： <br /><pre class="brush:java">/**********************************************************************************/<br />/*  Problem: c082 "Mutant Flatworld Expolrers" from ACM 118                       */<br />/*  Language: JAVA (2170 Bytes)                                                   */<br />/*  Result: AC(84ms, 1.3MB) judge by this@ZeroJudge                               */<br />/*  Author: mushiyo at 2013-05-21 21:23:12                                        */<br />/**********************************************************************************/<br /><br /><br />package UVa;<br /><br />import java.util.Map;<br />import java.util.HashMap;<br />import java.util.Scanner;<br />import java.awt.Point;<br /><br />public class c082 {<br /> static final int N = 0, E = 1, S = 2, W = 3;<br /> static final int[] leftDirection = { W, N, E, S };<br /> static final int[] rightDirection = { E, S, W, N };<br /> static final char[] charDirection = { 'N', 'E', 'S', 'W' };<br /><br /> public static void main(String[] args) {<br />  Scanner input = new Scanner(System.in);<br />  int boundaryX = input.nextInt();<br />  int boundaryY = input.nextInt();<br />  Map&lt;Point, Boolean&gt; scent = new HashMap&lt;Point, Boolean&gt;();<br /><br />  while (input.hasNext()) {<br />   int currentX = input.nextInt();<br />   int currentY = input.nextInt();<br />   char directionChar = input.next().charAt(0);<br />   int direction = 0;<br /><br />   switch (directionChar) {<br />   case 'N':<br />    direction = N;<br />    break;<br />   case 'E':<br />    direction = E;<br />    break;<br />   case 'S':<br />    direction = S;<br />    break;<br />   case 'W':<br />    direction = W;<br />    break;<br />   }<br /><br />   String instrucion = input.next();<br /><br />   boolean outOfBound = false;<br />   for (int i = 0; i &lt; instrucion.length(); ++i) {<br />    directionChar = instrucion.charAt(i);<br /><br />    int newX = currentX;<br />    int newY = currentY;<br /><br />    switch (directionChar) {<br />    case 'R':<br />     direction = rightDirection[direction];<br />     break;<br />    case 'L':<br />     direction = leftDirection[direction];<br />     break;<br />    case 'F':<br />     switch (direction) {<br />     case N:<br />      ++newY;<br />      break;<br />     case E:<br />      ++newX;<br />      break;<br />     case S:<br />      --newY;<br />      break;<br />     case W:<br />      --newX;<br />      break;<br />     }<br /><br />     break;<br />    }<br /><br />    if (newX &lt; 0 || newY &lt; 0 || newX &gt; boundaryX<br />      || newY &gt; boundaryY) {<br />     Point p = new Point(currentX, currentY);<br /><br />     if (!scent.containsKey(p)) {<br />      scent.put(p, true);<br />      outOfBound = true;<br /><br />      break;<br />     }<br /><br />    } else {<br />     currentX = newX;<br />     currentY = newY;<br />    }<br />   }<br /><br />   if (outOfBound) {<br />    System.out.println(currentX + " " + currentY + " " + charDirection[direction] + " LOST");<br />   }else{<br />    System.out.println(currentX + " " + currentY + " " + charDirection[direction]);<br />   }<br /><br />  }<br /> }<br />}<br /><br /></pre>
