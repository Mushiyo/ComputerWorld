title=〔大學生程式解題系統〕 d018: 2007 程式達人 A - 克林貢人的血腥遊戲
date=2013-08-16 21:50
full_date=2013-08-16T21:50:00.002+08:00
type=post
allowComment=true
tags=【競賽＆解題】, 〔大學生程式解題系統〕
status=published
~~~~~~

題目：<a href="http://judge.nccucs.org/ShowProblem?problemid=d018">http://judge.nccucs.org/ShowProblem?problemid=d018</a><br /><!--more--><br />解題雜記： <br />　　題目要求的是能走的最遠的路徑，所以8 x 8方格中的每一格格子都是可能的起點。底下的做法就是一一枚舉各個起點，然後看哪個起點能走出的路徑最長。注意「先前碰過的數字」是指經過移動後，在某格上看見的數字。所以是離開起點後遇到的數字才算數。而為了省去邊界判斷減少程式碼的複雜度，底下的程式碼在8 x 8方格的外面加了一圈數字25，並將數字25設成已走過的數字。這樣就能保證不會走出邊界，同時也就不用做邊界判斷了。<br /><br />C++： <br /><pre class="brush:c">/*Filename: d018.cpp<br /> *Author: Mushiyo<br /> */<br /><br />#include &lt;iostream&gt;<br />#include &lt;vector&gt;<br /><br />using namespace std;<br /><br />const int SIZE = 8 + 2;<br />int board[SIZE][SIZE];<br /><br />vector&lt;int&gt; getPath(int x, int y) {<br /> vector&lt;int&gt; path;<br /><br /> bool hasPassed[26];<br /> hasPassed[25] = true;<br /> for (int i = 0; i &lt; 25; ++i) {<br />  hasPassed[i] = false;<br /> }<br /><br /> bool isFirstNumber = true;<br /> bool unexploded = true;<br /><br /> while (unexploded) {<br />  // right<br />  if (hasPassed[board[x][y + 1]] == false) {<br />   ++y;<br />   hasPassed[board[x][y]] = true;<br />   path.push_back(board[x][y]);<br />   continue;<br />  }<br /><br />  // left<br />  if (hasPassed[board[x][y - 1]] == false) {<br />   --y;<br />   hasPassed[board[x][y]] = true;<br />   path.push_back(board[x][y]);<br />   continue;<br />  }<br /><br />  // down<br />  if (hasPassed[board[x + 1][y]] == false) {<br />   ++x;<br />   hasPassed[board[x][y]] = true;<br />   path.push_back(board[x][y]);<br />   continue;<br />  }<br /><br />  // up<br />  if (hasPassed[board[x - 1][y]] == false) {<br />   --x;<br />   hasPassed[board[x][y]] = true;<br />   path.push_back(board[x][y]);<br />   continue;<br />  }<br /><br />  unexploded = false;<br /> }<br /><br /> return path;<br />}<br /><br />int main() {<br /> for (int i = 0; i &lt; 10; ++i) {<br />  board[0][i] = 25;<br />  board[9][i] = 25;<br />  board[i][0] = 25;<br />  board[i][9] = 25;<br /> }<br /><br /> int startNum = 0;<br /><br /> while (cin &gt;&gt; startNum) {<br />  board[1][1] = startNum;<br />  for (int i = 2; i &lt;= 8; ++i) {<br />   cin &gt;&gt; board[1][i];<br />  }<br /><br />  for (int i = 2; i &lt;= 8; ++i) {<br />   for (int j = 1; j &lt;= 8; ++j) {<br />    cin &gt;&gt; board[i][j];<br />   }<br />  }<br /><br />  vector&lt;int&gt; longestPath;<br />  for(int i = 1; i &lt;= 8; ++i){<br />   for(int j = 1; j &lt;= 8; ++j){<br />    vector&lt;int&gt; currentPath = getPath(i, j);<br /><br />    if(currentPath.size() &gt; longestPath.size()){<br />     longestPath = currentPath;<br />    }<br />   }<br />  }<br /><br />  cout &lt;&lt; longestPath[0];<br />  for(int i = 1; i &lt; longestPath.size(); ++i){<br />   cout &lt;&lt; " " &lt;&lt; longestPath[i];<br />  }<br />  cout &lt;&lt; endl;<br /><br />  cout &lt;&lt; endl;<br /> }<br /><br /> return 0;<br />}<br /><br /></pre>
